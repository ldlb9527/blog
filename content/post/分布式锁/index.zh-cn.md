+++
author = "旅店老板"
title = "分布式事务"
date = "2024-05-04"
description = "分布式事务的多种模式说明"
tags = [
	"","",
]
categories = [
    "","",
]
series = [""]
aliases = ["distributed-transactions"]
image = "golang.png"
mermaid = true
+++
## 概述
常见解决方案有2PC、TCC、可靠消息最终一致性、最大努力通知
### 2PC
2指两个阶段提交协议，P(prepare)指准备阶段，C(commit)指提交阶段。

准备阶段:  
有一个事务管理器，分别参与者A和参与者B等发送prepare消息，它们在本地开启并执行事务,但不提交  

提交阶段:  
如果事务管理器收到执行错误或超时,直接给每个参与者发送回滚（RollBack)消息,如果没有则发送提交(Commit)消息

缺点:
* 同步阻塞，所有参与者需要等待事务处理器到底是提交还是回滚
* 事务管理器可用性
* 发生网络分区等只有部分收到了提交或回滚
* 每个参与者可能都会持有一把锁
1. 如何处理事务管理器和参与者的 通信故障  
2PC协调者的超时机制
***
### 3PC
3PC实在2PC的基础上进行了优化的分布式事务协议，它通过增加一个额外的阶段来减少同步阻塞和单点故障的风险  
三个阶段分别为canCommit 回复ok   preCommit 回复ack(docommit或rollback) doCommit（docommit或rollback)   

第二阶段执行事务但不提交   第三阶段提交事务或回滚



3PC协调者和参与者都有超时机制  

第二阶段部分参与者收到预提交   其他超时或未收到的参与者会直接回滚

第三阶段如果部分参与者收到提交  其他超时或未收到的参与者可直接提交(前两个阶段都ok 表示提交的成功可能很高)

由上可知第三阶段的网络原因仍会导致数据不一致  概率要比2PC低
***
### AT模式(自动补偿型事务模式)
可以看作2PC的变种，主要引入了补偿操作，解决2PC的某些问题 比如事务协调者自动生成回滚的sql
### TCC事务
TCC是Try、Confirm、Cancel。要求每个分支事务实现这三个操作。Try做业务检查和资源预留， Confirm做业务确认操作 Cancel实现一个与Try相反
的操作即回滚操作
try都成功后 confirm 失败需要重试   try有失败  其它执行cancel cancel执行失败需要重试  

由于confirm、cancel都可能执行到失败重试  它们需要实现幂等性  

cancel需要手动写回滚逻辑  

开始库存为100  可用库存为100  冻结库存为0  try阶段开始库存为100  可用库存为98  冻结库存为2  
try有失败执行cancel
confirm阶段真正扣除

***
### saga模式
将一个复杂事务拆分为多个小事务  
* 基于事件的方式：订单服务提交本地事务后会产生一个事件，支付服务监听到这个事件 也执行本地事务 继续产生事件 通知到下一个  
以此类推  
如果中间某个服务出现异常, 比如产生一个库存不足的异常  前面流程的服务都会收到这个消息 订单服务设置为失败  支付服务进行退款
缺点: 这种方式如果涉及到较多的参与方，容易失控  还容易产生环形监听的问题 两个服务互相监听对方的事件  
优点: 没有协调者


* 基于命令的方式：订单服务向协调者创建一个事务,各个参与者收到协调者的消息 执行事务  如果其中有失败  通知协调者  协调者通知其他参与者回滚  
优点:各个参与者解耦
### 可靠消息最终一致性
本地事务的执行和消息的发送要原子性   事务成功  消息一定发出
1.比如事务成功  消息发送超时  该如何回滚  超时可能发送成功可能失败  发送端如何感知
2.如果消息接受失败 中间件需重复投递消息
3.由于2消息消费要幂等
***
### 最大努力通知
与可靠消息最终一致性的区别在于 可靠消息最终一致性要保证消息传递可靠性 强调发送方主动要成功

最大努力通知强调发送方尽最大努力 但不一定成功  接收方可定时来检查   强调接收方主动要成功
